

### **問題背景描述：為低階應用程式 (Warp Terminal) 轉譯遠端桌面 (RDP) 軟鍵盤輸入信號**

#### 1. 總覽 (Executive Summary)

本問題旨在尋求一個軟體解決方案（如腳本、工具或背景服務），以解決在特定環境下，輸入信號無法被目標應用程式辨識的問題。核心挑戰是，來自 Android RDP 客戶端軟鍵盤的輸入信號，在 Windows 主機上是以高階的軟體事件形式存在的，而目標應用程式 Warp Terminal 為了追求效能，只監聽低階的硬體掃描碼 (Scancode) 事件。我們需要一個「轉譯器」來攔截前者並模擬後者。

#### 2. 系統環境

*   **主機作業系統**: Windows (10 / 11)
*   **目標應用程式**: [Warp Terminal](https://www.warp.dev/) ***目前發現 VS Code 中的 Claude Code 外掛程式 有一模一樣的現象 懷疑原因相同***
*   **遠端客戶端**: 運行於 Android 裝置上的官方 **Microsoft Remote Desktop** 應用程式。
*   **輸入方式**: Android 裝置上的**螢幕軟鍵盤 (Soft Keyboard)**。

#### 3. 詳細問題描述

1.  **成功場景**:
    *   在 Windows 主機上直接使用**實體鍵盤**，可以在 Warp Terminal 中正常輸入。
    *   透過 Android RDP 連線後，使用軟鍵盤在大多數標準 Windows 應用程式（如 **記事本 Notepad, 命令提示字元 CMD, 瀏覽器**）中可以正常輸入。

2.  **失敗場景**:
    *   透過 Android RDP 連線後，使用軟鍵盤在 **Warp Terminal** 應用程式中輸入時，**完全沒有任何反應**。應用程式無法偵測到任何按鍵事件。

#### 4. 已知的根本原因 (Root Cause Analysis)

Warp 官方技術支援已確認問題所在。這並非一個傳統意義上的 Bug，而是一個底層架構設計所導致的相容性問題。

*   **Warp Terminal 的輸入機制**: 為了達到極致的低延遲和高效能，Warp 直接監聽來自作業系統底層的**硬體掃描碼 (Hardware Scancodes)**。這種方式類似於高效能遊戲引擎，可以繞過一些標準的 Windows 輸入處理層級，從而獲得更快的反應速度。

*   **RDP 軟鍵盤的輸入機制**: RDP 客戶端將來自軟鍵盤的輸入（例如字元 'a'）發送到 Windows 主機後，遠端桌面服務會以一種**高階的軟體事件**形式將其「注入」到系統中。這通常是透過 `SendInput` 函式發送 Unicode 字元，或觸發 `WM_CHAR` 之類的視窗訊息。

*   **核心衝突**: Warp 設計來監聽「硬體語言」(Scancodes)，而 RDP 軟鍵盤正在說「軟體語言」(Character Injection)。因此，Warp 完全「聽不見」來自 RDP 軟鍵盤的輸入。

#### 5. 專案目標 (Objective)

設計並實作一個在 Windows 主機上運行的「轉譯器」，其功能如下：

1.  **攔截 (Hook/Intercept)**: 在全域範圍內捕獲由 RDP 服務注入的鍵盤事件。
2.  **轉譯 (Translate)**: 將捕獲到的高階按鍵事件（例如字元 'a' 或虛擬按鍵碼 `VK_A`）轉換為其對應的低階**硬體掃描碼**（例如 `0x1E`）。
3.  **重新發送 (Re-send/Inject)**: 使用 Windows 的低階 API（如 `SendInput`）並明確指定 `KEYEVENTF_SCANCODE` 旗標，來模擬一次基於硬體掃描碼的按鍵按下與釋放事件。

這個轉譯器應該作為一個中間層，將 RDP 軟鍵盤的輸出「翻譯」成 Warp 能聽懂的語言。

#### 6. 關鍵限制與簡化條件

*   **純軟鍵盤環境**: 解決方案可以假設**不會有實體鍵盤**在 Windows 主機上同時被使用。這極大地簡化了問題，因為不需要處理來自多個來源的輸入，也避免了轉譯器攔截到自己發送事件而造成的無限迴圈問題。
*   **平台限制**: 解決方案必須在 Windows 上運行。
*   **無效的替代方案**: Warp 官方建議的「使用 Windows 內建螢幕小鍵盤 (OSK)」方法因嚴重影響操作流暢性，不被視為一個可行的解決方案。

#### 7. 潛在的技術實現方案（不限語言）

歡迎使用任何適合的語言或工具來解決此問題，包括但不限於：

*   **Python**:
    *   **攔截**: 使用 `pynput` 或 `keyboard` 函式庫。
    *   **發送**: 使用 `ctypes` 模組直接呼叫 `user32.dll` 中的 `SendInput` API，並手動建構包含掃描碼的 `KEYBDINPUT` 結構體。

*   **AutoHotkey (AHK)**:
    *   AHK 是專為此類 Windows 自動化和輸入操控而設計的腳本語言。它內建了強大的鍵盤掛鉤 (`Hook`) 和虛擬輸入 (`Send`) 功能，並且能夠精確控制發送的事件類型，是此問題的強力候選方案。

*   **C++ / C# / Rust**:
    *   這些編譯語言提供了與 Windows API 互動的最直接、最高效能的方式。
    *   **攔截**: 可以使用 `SetWindowsHookEx` 建立一個全域低階鍵盤掛鉤 (`WH_KEYBOARD_LL`)。
    *   **發送**: 同樣是呼叫 `SendInput` API。
    *   使用這些語言可以將解決方案編譯成一個輕量級、高效的 `.exe` 背景服務，無需安裝龐大的執行環境。

---